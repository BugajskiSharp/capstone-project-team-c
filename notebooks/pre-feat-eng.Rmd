---
title: "Preprocessing and Feature Engineering"
date: "2025-11-20"
output: html_document
---

Load libraries
```{r}
library(here)
library(dplyr)
library(knitr)
library(tidyr)
library(ggplot2)
library(corrplot)
library(VIM)
```

Importing the data
```{r}
final_data <- read.csv(here("data", "merged_marathon_data.csv"))
```

```{r}
# view merged data
str(final_data)
summary(final_data)
```
Looking at the full dataset for missing values 
```{r}
# missing values for visibility, co, pm10, pm2.5
missing_summary <- final_data %>%
  summarise(across(everything(), ~sum(is.na(.))))

knitr::kable(missing_summary, caption = "Missing Values per Variable")
```

# Spliting the data so Berlin is used as a second case study to show how the method performs with missing data (whether successful or not).

```{r}
main_data <- final_data %>% filter(marathon != "Berlin")
berlin_data <- final_data %>% filter(marathon == "Berlin")
```

```{r}
str(main_data)
```
# Handling Missing Values
```{r}
# missing values
missing_summary <- main_data %>%
  summarise(across(everything(), ~sum(is.na(.))))

knitr::kable(missing_summary, caption = "Missing Values per Variable")
```

Since PM10 has alot of missing values still, we will drop that column completely 
```{r}
main_data <- main_data %>%
  select(-pm10) 
```

Since PM2.5 is often the main pollutant, we decided to use KNN imputation to fill missing PM2.5 values because it predicts missing data using similar rows without assuming a specific parametric relationship, preserves variance, and works well for our relatively small dataset while using correlations with other environmental variables
```{r}
# Impute missing PM2.5 values using 5 nearest neighbors
main_data <- kNN(main_data, variable = "pm25", k = 5) # can change later to see which K gives best model performance 

# remove pm25_imp
cols_to_remove <- c(
  "pm25_imp"
)

main_data <- main_data[, !(names(main_data) %in% cols_to_remove)]

# Check that missing values are filled
summary(main_data$pm25)
```


Convert categorical variables to factors
```{r}
main_data  <- main_data  %>%
  mutate(subgroup = factor(subgroup),
         gender = factor(gender),
         marathon = factor(marathon),
         main_pollutant = factor(main_pollutant))

str(main_data )
```
# Feature engineering 

```{r}
# create interaction terms and convert supershoe to factor
main_data <- main_data %>%
  mutate(
    supershoe = factor(ifelse(year >= 2018, 1, 0), levels = c(0, 1)),
    temp_dew_interaction       = avg_temp * dew_point,
    temp_aqi_interaction       = avg_temp * aqi, 
    temp_precip_interaction    = avg_temp * precipitation,
    temp_wind_interaction      = avg_temp * wind_speed,
    pm25_temp_interaction      = pm25 * avg_temp,
    dew_wind_interaction       = dew_point * wind_speed,
    pressure_temp_interaction  = sea_level_pressure * avg_temp,
    avg_temp_gender_interaction = avg_temp * as.numeric(gender == "male")
  )

str(main_data)
```

# Need to do a Quick correlation check for numeric variables and see what features inroduce multicollinearity

```{r}
# Find numeric columns after feature engineering, excluding 'year'
numeric_vars <- main_data %>%
  select(where(is.numeric)) %>%
  select(-year) %>% 
  names()

numeric_vars
```

Correlation matrix
```{r}
cor_matrix <- cor(main_data[numeric_vars], use = "pairwise.complete.obs")

# rounding
round(cor_matrix, 2)
```

```{r}
corrplot(
  cor_matrix,
  method = "color",
  col = colorRampPalette(c("blue", "white", "red"))(200),
  tl.cex = 0.6
)
```

Observing categorical variables and their distributions
```{r}
table(main_data$pm25_imp) # think this will error out since pm25_imp is removed above
table(main_data$main_pollutant)
table(main_data$supershoe)
```

Removing correlated variables
```{r}
cols_to_remove <- c(
  "high_temp",
  "low_temp",
  "aqi",
  "temp_dew_interaction",
  "temp_precip_interaction",
  "temp_wind_interaction",
  "pm25_temp_interaction",
  "dew_wind_interaction",
  "pressure_temp_interaction",
  "main_pollutant" 
)

main_data <- main_data[, !(names(main_data) %in% cols_to_remove)]
str(main_data)

```

# Data Scaling (for linear regression model)

```{r}
# Identify numeric predictors to scale (exclude outcome and identifiers)
numeric_vars <- main_data %>%
  select(where(is.numeric)) %>%
  select(-avg_chip_seconds, -year, -n) %>%
  names()

# Create scaled versions of the numeric predictors (scaled variables with "scaled_")
scaled_vars <- paste0("scaled_", numeric_vars)
main_data[scaled_vars] <- scale(main_data[numeric_vars])

str(main_data)

```


```{r}
# summary of scaled variables
summary(main_data[scaled_vars])

```

#(Ended HERE)

# adding our 90/10 training/test split
```{r}
# split data into train and test
set.seed(123)

train_index <- sample(1:nrow(main_data), size = 0.9 * nrow(main_data)) # use a 90/10 split

train_data <- main_data[train_index, ]
test_data  <- main_data[-train_index, ]
```


------------------------
IDEAS:

# indicate and define year of covid
final_data <- final_data %>%
  mutate(
    covid_era = ifelse(year == 2020, 1, 0)
  )



# replacing the numeric variables with missing data with mean (could do median if we keep this); most likely dropping though
numeric_vars <- final_data %>%
  select(where(is.numeric)) %>%
  names()

final_data <- final_data %>%
  mutate(across(all_of(numeric_vars), ~ifelse(is.na(.), mean(., na.rm = TRUE), .)))



# create custom cutoff times for performance groups
final_data <- final_data %>%
  mutate(
    finish_hours = avg_chip_seconds / 3600, # think we are having all time in seconds, need fixing
    subgroup2 = case_when(
      finish_hours < 3 ~ "elite",
      finish_hours < 3.75 ~ "competitive",
      finish_hours < 4.75 ~ "average",
      finish_hours < 5.75 ~ "recreational",
      TRUE ~ "slow"
    )
  )

# create interaction terms and convert supershoe to factor
main_data <- main_data %>%
  mutate(
    pm25_imp  = factor(pm25_imp, levels = c(FALSE, TRUE)), # i dont think we need this
    supershoe = factor(ifelse(year >= 2018, 1, 0), levels = c(0, 1)),
    temp_dew_interaction       = avg_temp * dew_point,
    temp_aqi_interaction       = avg_temp * aqi, # optional
    temp_precip_interaction    = avg_temp * precipitation,
    temp_wind_interaction      = avg_temp * wind_speed,
    pm25_temp_interaction      = pm25 * avg_temp,
    dew_wind_interaction       = dew_point * wind_speed,
    pressure_temp_interaction  = sea_level_pressure * avg_temp,
    avg_temp_gender_interaction = avg_temp * as.numeric(gender == "male")
  )

str(main_data)
